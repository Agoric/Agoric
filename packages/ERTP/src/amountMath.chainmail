/**
 * Units are asset descriptions and take the form of branded extents. 
 * UnitOps execute the logic of how units are changed when digital 
 * assets are merged, separated, or otherwise manipulated. For
 * example, a deposit of 2 bucks into a purse that already has 3 bucks
 * gives a new balance of 5 bucks. An empty purse has 0 bucks. UnitOps 
 * relies heavily on ExtentOps, which manipulates the unbranded
 * portion.
 */
struct Units (Brand, Extent) {
  brand :Brand;
  extent :Extent;
}

/**
 * Extents describe the extent of something that can be owned or shared.
 * Fungible extents are normally represented by natural numbers. Other 
 * extents may be represented as strings naming a particular right, or 
 * an arbitrary object that sensibly represents the rights at issue. 
 *
 * Extent must be Comparable. (This IDL doesn't yet provide a way to specify
 * subtype relationships for structs.)
 */
struct Extent {
}

/**
 * Operations on Units.
 *
 * Units are the canonical description of tradable goods. They are manipulated
 * by mints, and represent the goods and currency carried by purses and
 * payments. They can be used to represent things like currency, stock, and the
 * abstract right to participate in a particular exchange.
 *
 */
interface UnitOps (Units (Brand, Extent)) {

  /** Return this unitOps's brand. */
  getBrand() -> (Brand);

  /** Get the name of the extentOps used. */
  getExtentOpsName -> (String);

  /**  Make units from an extent by adding the brand. */
  make(allegedExtent :Extent) -> (Units);

  /**
   * Make sure these units (or extent) are valid and return them if so.
   */
  coerce(allegedUnitsOrExtent :Units) -> (Units);

  /** Remove the brand and return the extent. */
  extent(units :Units) -> (Extent);

  /** Return the units representing an empty amount. This is the
   * identity element in ExtentOps.
   */
  empty() -> (Units);

  /** Return true if the Units is empty. Otherwise false. */
  isEmpty(units :Units) -> (boolean);

  /** Returns true if the leftUnits contains the rightUnits. */
  includes(leftUnits :Units, rightUnits :Units) -> (boolean);

  /** 
   * Returns true if the leftUnits equals the rightUnits. We assume
   * that if includes is true in both directions, equals is also true 
   */
  equals(leftUnits :Units, rightUnits :Units) -> (boolean);

  /**
   * Returns a new units that includes both leftUnits and rightUnits.
   *
   * For fungible units this means adding the extents. For other kinds of
   * units, it usually means including both.
   */
  with(leftUnits :Units, rightUnits :Units) -> (Units);

  /**
   * Returns a new units that includes the portion of leftUnits not included
   * in rightUnits. If leftUnits doesn't include rightUnits, throw an error.
   */
  without(leftUnits :Units, rightUnits :Units) -> (Units);
}

/**
 * The brand identifies the kind of assay, and has a function to get the
 * alleged name for the kind of asset described. The alleged name (such
 * as 'BTC' or 'moola') is provided by the maker of the mint and should 
 * not be trusted as accurate.
 *
 * Every units created by the UnitOps will have the same brand, but recipients
 * cannot use the brand by itself to verify that a purported units is
 * authentic, since the brand can be copied. 
 */
interface Brand ( ) {
  isMyAssay (assay :Assay) -> (Boolean);
  allegedName ( ) -> (String);
}

/**
 * Human-readable name of a kind of digital asset. The alleged name should 
 * not be trusted as an accurate depiction, since it is provided by 
 * the maker of the mint and could be deceptive.
 *
 * The AllegedName must be Comparable. (This IDL doesn't yet provide a way to
 * specify subtype relationships for structs.)
 */
struct AllegedName {
}

/**
 * ExtentOps for a branded natural number describing a extent of fungible
 * digital assets, used by unitOps by default. 
 *
 * Empty units have zero units. 'includes()' verifies that leftUnits is
 * greater than or equal to rightUnits. 'with()' and 'without()' add and
 * subtract their contents.
 */
interface NatExtentOps () {
}
