/**
 * Zoe is a long-lived and well-trusted contract that enforces
 * offer safety for the contracts that run on it. The ZoeService is the
 * client- or user-facing Zoe API. There is also a separate API exposed
 * to the contracts.
 */

interface ZoeService {

  /**
   * Zoe has a single `inviteIssuer` for the entirety of its lifetime. 
   * By having a reference to Zoe, a user can get the `inviteIssuer` 
   * and thus validate any `invite` they receive from someone else. The
   * mint associated with the inviteIssuer creates the ERTP payments 
   * that represent the right to interact with a smart contract in 
   * particular ways.
   */
  getInviteIssuer() -> (Issuer);

  /**
   * Create an installation by safely evaluating the code and
   * registering it with Zoe. Returns an installationHandle. 
   */
  install(code :String, moduleFormat :String) -> (InstallationHandle);
  
  /** 
   * Zoe is long-lived. We can use Zoe to create smart contract
   * instances by specifying a particular contract installation to 
   * use, as well as the `issuerKeywordRecord` and `terms` of the contract. The
   * `issuerKeywordRecord` is a record mapping string names (keywords) to issuers,
   * such as `{ Asset: simoleanIssuer}`. (Note that the keywords must
   * begin with a capital letter and must be ASCII.) Parties to the
   * contract will use the keywords to index their proposal and
   * their payments.
   * The payout users receive from Zoe will be in the form of an object
   * with keywords as keys. Terms are the arguments to the contract,
   * such as the number of bids an auction will wait for before closing.
   * Terms are up to the discretion of the smart contract. We get back
   * an invite (an ERTP payment) to participate in the contract.
   */
  makeInstance(installationHandle :InstallationHandle, issuerKeywordRecord :IssuerKeywordRecord, terms :Object) -> (Invite);
  
  /**
   * Credibly get information about the instance (such as the installation
   * and terms used).
   */
  getInstance(instanceHandle :InstanceHandle) -> (InstanceRecord);

  /** 
   * To redeem an invite, the user must provide a proposal (their rules for the
   * offer) as well as payments to be escrowed by Zoe.
   * 
   * The proposal has three parts: `want` and `give` are used 
   * by Zoe to enforce offer safety, and `exit` is used to specify
   * the extent of payout liveness that Zoe can guarantee.
   * `want` and `give` are objects with keywords as keys and amounts
   * as values. `payments` is a record with keywords as keys,
   * and the values are the actual payments to be escrowed. A payment
   * is expected for every rule under `give`.
   */
  redeem (invite :Invite, proposal :Proposal, payments :PaymentKeywordRecord)) -> (SeatAndPayout);
}

/**
 * This is returned by a call to `redeem` on Zoe.
 * A seat is an arbitrary object whose methods allow the user to take
 * certain actions in a contract. The payout is a promise that resolves
 * to an object which has keywords as keys and promises for payments
 * as values. Note that while the payout promise resolves when an offer
 * is completed, the promise for each payment resolves after the remote
 * issuer successfully withdraws the payment.
 */
struct SeatAndPayout ( ) {
  seat :Object;
  payout :List(Payment);
}

struct Proposal ( ) {
  want :AmountKeywordRecord;
  give :AmountKeywordRecord;
  exit :ExitRule;
}

/**
 * The keys are keywords, and the values are amounts. For example:
 * { Asset: amountMath.make(5), Price: amountMath.make(9) }
 */
struct AmountKeywordRecord ( ) {
}

/**
 * The possible keys are 'waived', 'onDemand', and 'afterDeadline'.
 * `timer` and `deadline` only are used for the `afterDeadline` key.
 * The possible records are:
 * `{ waived: null }`
 * `{ onDemand: null }`
 * `{ afterDeadline: { timer :Timer<Deadline>, deadline :Deadline } }
 */
struct ExitRule ( ) {
  timer :Timer;
  deadline :Deadline;
}

interface ZoeContractFacet () {

  /** 
   * Instruct Zoe to try reallocating for the given offerHandles.
   * Reallocation is an array of AmountKeywordRecords, which are objects where
   * the keys are keywords and the values are amounts. The
   * amounts to be paid to the player who made the offer at the same
   * index in the offerHandles array. The reallocation will only happen if
   * 'offer safety' and conservation of rights are true, as enforced by Zoe.
   */
  reallocate (offerHandles :List(OfferHandle), reallocation :List(AmountKeywordRecord));

  /** 
   * Eject the offer, taking the current allocation for that offer and
   * creating payments to be returned to the user. No 'offer safety' checks are
   * done here because any previous reallocation performed those checks.
   */
  complete (offerHandles :List(OfferHandle));
  
  /** Create an invite using the Zoe inviteMint */
  makeInvite (seat :Object, customProperties :Object ) -> (Invite);

  /** 
   * Inform Zoe about new issuers. Returns a promise for acknowledging
   * when the issuer is added and ready.
   */
  addNewIssuer (issuer :Issuer, keyword :String) -> (Promise(Undefined));

  /**
   * Expose the user-facing Zoe Service API to the contracts as well.
   */
  getZoeService ( ) -> (ZoeService);

  ////// The methods below are pure and have no side-effects. ////////

  /** Get the Zoe inviteIssuer */
  getInviteIssuer ( ) -> (Issuer);

  /** Get a list of local amountMath for each keyword in the issuerKeywordRecord
  object */
  getAmountMaths (issuerKeywordRecord :IssuerKeywordRecord) -> (AmountMathKeywordRecord));

  /** Divide the offerHandles into 'active' and 'inactive' lists */
  getOfferStatuses ( offerHandles :List(OfferHandle)) ->
  (OfferStatusesRecord);

  /** 
   * Check if the offer is still active. This method does not throw
   * if the offer is inactive.
   */
  isOfferActive ( offerHandle :OfferHandle ) -> (Bool);

  /** Get a list of offer records */
  getOffers ( offerHandles :List(OfferHandle)) -> (List(OfferRecord));

  /** Get the offer record */
  getOffer ( offerHandle :OfferHandle) -> (List(OfferRecord));

  /** Get instance record */
  getInstanceRecord ( ) -> InstanceRecord;

}

/**
 * `active` and `inactive` lists of offerHandles.
 */
 struct OfferStatusesRecord ( ) {
  active :List(OfferHandle);
  inactive :List(OfferHandle);
}
